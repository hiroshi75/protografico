---
name: fine-tune
description: Use when you need to fine-tune and optimize LangGraph applications based on evaluation criteria. This skill performs iterative prompt optimization for LangGraph nodes without changing the graph structure.
---

# LangGraph アプリケーションファインチューニングスキル

LangGraph アプリケーションの各ノードのプロンプトと処理ロジックを、評価基準に基づいて反復的に最適化するスキル。

## 📋 概要

このスキルは、既存の LangGraph アプリケーションのパフォーマンスを向上させるため、以下のプロセスを実行します：

1. **目標設定の読み込み**: `.langgraph-master/fine-tune.md` から最適化の目標と評価基準を取得（このファイルがない場合、ユーザーの要求に沿って作ってあげてください。）
2. **最適化箇所の特定**: Serena MCP を活用して LLM プロンプトを含むノードを抽出（Serena MCP が無い場合、ls, read などでコードベースを調べてください。）
3. **ベースライン評価**: 現状のパフォーマンスを複数回実行して測定
4. **改善の実施**: 最も効果的な改善箇所を特定し、プロンプトや処理ロジックを最適化
5. **再評価**: 改善後のパフォーマンスを測定
6. **反復**: 目標達成まで 4-5 を繰り返す

**重要な制約**: グラフ構造（ノード、エッジの構成）は変更せず、各ノード内のプロンプトと処理ロジックのみを最適化します。

## 🎯 使用タイミング

以下の場合にこのスキルを使用します：

1. **既存アプリケーションの性能改善が必要な場合**
   - LLM の出力品質を向上させたい
   - 応答速度を改善したい
   - エラー率を低減したい

2. **評価基準が明確な場合**
   - `.langgraph-master/fine-tune.md` に最適化目標が定義されている
   - 定量的な評価方法が確立されている

3. **プロンプトエンジニアリングによる改善が期待できる場合**
   - LLM の指示を明確にすれば改善が見込める
   - Few-shot examples の追加が有効
   - 出力フォーマットの調整が必要

## 📖 ファインチューニングワークフロー概要

### Phase 1: 準備と分析

**目的**: 最適化の対象と現状を把握

**主要ステップ**:
1. 目標設定ファイル（`.langgraph-master/fine-tune.md`）の読み込み
2. 最適化対象の特定（Serena MCP または手動でコード調査）
3. 最適化箇所リストの作成（各ノードの改善可能性を評価）

→ 詳細は [workflow.md](workflow.md#phase-1-準備と分析) を参照

### Phase 2: ベースライン評価

**目的**: 現状のパフォーマンスを定量的に測定

**主要ステップ**:
4. 評価環境の準備（テストケース、評価スクリプト）
5. ベースライン測定（推奨: 3-5 回実行）
6. ベースライン結果の分析（問題点の特定）

**重要**: 評価プログラムが必要な際は、特定のサブディレクトリに評価用コードを作成してください（ユーザーからディレクトリを指定される場合もあります）。

→ 詳細は [workflow.md](workflow.md#phase-2-ベースライン評価) と [evaluation.md](evaluation.md) を参照

### Phase 3: 反復的改善

**目的**: データ駆動で段階的に改善

**主要ステップ**:
7. 優先順位付け（最もインパクトのある改善箇所を選択）
8. 改善実施（プロンプト最適化、パラメータ調整）
9. 改善後の評価（同じ条件で再評価）
10. 結果の比較と分析（改善効果の測定）
11. 反復継続の判断（目標達成まで繰り返し）

→ 詳細は [workflow.md](workflow.md#phase-3-反復的改善) と [prompt_optimization.md](prompt_optimization.md) を参照

### Phase 4: 完了と文書化

**目的**: 成果の記録と今後の推奨事項の提供

**主要ステップ**:
12. 最終評価レポート作成（改善内容、結果、推奨事項）
13. コードコミットとドキュメント更新

→ 詳細は [workflow.md](workflow.md#phase-4-完了と文書化) を参照

## 🔧 使用ツールと技術

### MCP サーバー活用

- **Serena MCP**: コードベース分析と最適化箇所の特定
  - `find_symbol`: LLM クライアントの検索
  - `find_referencing_symbols`: プロンプト構築箇所の特定
  - `get_symbols_overview`: ノード構造の理解

- **Sequential MCP**: 複雑な分析と意思決定
  - 改善優先順位の決定
  - 評価結果の分析
  - 次のアクションの計画

### 主要な最適化テクニック

1. **Few-Shot Examples**: Accuracy +10-20%
2. **出力フォーマット構造化**: Parsing errors -90%
3. **Temperature/Max Tokens 調整**: Cost -20-40%
4. **モデル選択の最適化**: Cost -40-60%
5. **プロンプトキャッシング**: Cost -50-90%（キャッシュヒット時）

→ 詳細は [prompt_optimization.md](prompt_optimization.md) を参照

## 📚 関連ドキュメント

詳細なガイドラインとベストプラクティス：

- **[workflow.md](workflow.md)** - ファインチューニングワークフロー詳細（各 Phase の実行手順とコード例）
- **[evaluation.md](evaluation.md)** - 評価方法とベストプラクティス（指標の計算、統計分析、テストケース設計）
- **[prompt_optimization.md](prompt_optimization.md)** - プロンプト最適化テクニック（10 の実践的手法と優先順位）
- **[examples.md](examples.md)** - 実践例集（コピー&ペーストで使えるコード例とテンプレート集）

## ⚠️ 注意事項

1. **グラフ構造の保持**
   - ノード、エッジの追加・削除は行わない
   - ノード間のデータフローは変更しない
   - 状態スキーマは維持する

2. **評価の一貫性**
   - 同じテストケースを使用
   - 同じ評価指標で測定
   - 複数回実行して統計的に有意な改善を確認

3. **コスト管理**
   - 評価実行のコストを考慮
   - 必要に応じてサンプルサイズを調整
   - API レート制限に注意

4. **バージョン管理**
   - 各 iteration の変更を git commit
   - ロールバック可能な状態を維持
   - 評価結果を記録

## 🎓 ファインチューニングのベストプラクティス

1. **小さく始める**: 最もインパクトのあるノードから最適化
2. **測定駆動**: 改善前後で必ず定量評価を実施
3. **段階的改善**: 一度に複数の変更をせず、1 つずつ検証
4. **文書化**: 各変更の理由と結果を記録
5. **反復**: 目標達成まで継続的に改善

## 🔗 参考リンク

- [LangGraph 公式ドキュメント](https://docs.langchain.com/oss/python/langgraph/overview)
- [Prompt Engineering Guide](https://www.promptingguide.ai/)
